import{_ as e,c as t,o,a as r}from"./app.4a2fb674.js";const p=JSON.parse('{"title":"Android 引导诡计","description":"","frontmatter":{},"headers":[{"level":2,"title":"术语","slug":"术语","link":"#术语","children":[]},{"level":2,"title":"引导方法","slug":"引导方法","link":"#引导方法","children":[{"level":3,"title":"讨论","slug":"讨论","link":"#讨论","children":[]}]},{"level":2,"title":"一些历史","slug":"一些历史","link":"#一些历史","children":[]},{"level":2,"title":"将事物拼凑在一起","slug":"将事物拼凑在一起","link":"#将事物拼凑在一起","children":[]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"relativePath":"boot.md","lastUpdated":1675020658000}'),d={name:"boot.md"},n=r('<h1 id="android-引导诡计" tabindex="-1">Android 引导诡计 <a class="header-anchor" href="#android-引导诡计" aria-hidden="true">#</a></h1><h2 id="术语" tabindex="-1">术语 <a class="header-anchor" href="#术语" aria-hidden="true">#</a></h2><ul><li><strong>rootdir</strong>：根目录 (<code>/</code>)。所有 文件、文件夹或文件系统 都存储在 rootdir 中或挂载在 rootdir 下。在 Android 上，文件系统可以是 <code>rootfs</code> 或 <code>system</code> 分区。</li><li><strong><code>initramfs</code></strong>：Android 启动映像中的一个部分，Linux 内核将使用它作为<code>rootfs</code>。人们也可以使用术语 <strong>ramdisk</strong></li><li><strong><code>recovery</code> 和 <code>boot</code> 分区</strong>：这两个实际上非常相似：都是包含 ramdisk 和 Linux 内核的 Android 启动映像（加上其他一些东西）。 唯一的区别是，启动 <code>boot</code> 分区将把我们带到 Android，而 <code>recovery</code> 有一个用于修复和升级设备的极简自带 Linux 环境。</li><li><strong>SAR</strong>：系统作为根（System-as-root）。也就是说，设备使用 <code>system</code> 作为rootdir，而不是 <code>rootfs</code></li><li><strong>A/B, A-only</strong>：对于支持<a href="https://source.android.google.cn/docs/core/ota/ab" target="_blank" rel="noreferrer">无缝系统更新</a>的设备，它将具有所有只读分区的2个插槽（partition）；我们称这些为<strong>A/B设备</strong>。为了区分，非A/B设备将称为<strong>A-only</strong></li><li><strong>2SI</strong>：两阶段初始化。Android 10+ 的启动方式。稍后提供更多信息。</li></ul><p>以下是一些参数，可帮助您更精确地定义设备的 Android 版本：</p><ul><li><strong>LV</strong>：推出版本。设备<strong>推出时</strong>使用的安卓版本。也就是说，设备首次上市时预装的 Android 版本。</li><li><strong>RV</strong>：运行版本。设备当前运行的 Android 版本。</li></ul><p>我们将使用 <strong>Android API 级别</strong> 来表示 LV 和 RV 。API 级别和 Android 版本之间的映射可以在 (<a href="https://source.android.google.cn/setup/start/build-numbers#platform-code-names-versions-api-levels-and-ndk-releases" target="_blank" rel="noreferrer">https://source.android.google.cn/setup/start/build-numbers#platform-code-names-versions-api-levels-and-ndk-releases</a>) 中看到。例如：Pixel XL 随 Android 7.1 发布，并运行 Android 10，这些参数将为 <code>(LV = 25, RV = 29)</code> 。</p><h2 id="引导方法" tabindex="-1">引导方法 <a class="header-anchor" href="#引导方法" aria-hidden="true">#</a></h2><p>Android 启动可以大致分为 3 种主要的不同方法。我们提供了一个一般的经验法则，以确定您的设备最有可能使用哪种方法，但例外情况单独列出。</p><table><thead><tr><th style="text-align:center;">方法</th><th>初始根目录</th><th>最终根目录</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>A</strong></td><td><code>rootfs</code></td><td><code>rootfs</code></td></tr><tr><td style="text-align:center;"><strong>B</strong></td><td><code>system</code></td><td><code>system</code></td></tr><tr><td style="text-align:center;"><strong>C</strong></td><td><code>rootfs</code></td><td><code>system</code></td></tr></tbody></table><ul><li><strong>方法 A - 传统 ramdisk</strong>：这是<em>所有</em> Android 设备过去启动的方式（过去的美好时光）。内核使用 <code>initramfs</code> 作为 rootdir，exec <code>/init</code> 来引导。 <ul><li>不属于方法 B 和 C 标准中的设备</li></ul></li><li><strong>方法 B - 传统 SAR</strong>：此方法首次出现在 Pixel 1 上。内核直接挂载 <code>system</code> 分区作为 rootdir 并且 exec <code>/init</code> 来引导。 <ul><li>具有 <code>(LV = 28)</code> 的设备</li><li>谷歌：Pixel 1 和 2。Pixel3 和 3a 为 <code>(RV = 28)</code> 时</li><li>一加：6 - 7</li><li>也许一些 <code>(LV &lt; 29)</code> Android Go 设备？</li></ul></li><li><strong>方法 C - 2SI ramdisk SAR</strong>：此方法首次出现在 Pixel 3 Android 10 开发者预览版中。内核使用 <code>initramfs</code> 作为 rootdir，在 <code>rootfs</code> 中使用 exec <code>/init</code>。这个 <code>init</code> 负责挂载 <code>system</code> 分区并将其用作新的 rootdir，最后执行 <code>/system/bin/init</code> 来引导。 <ul><li>具有 <code>(LV &gt;= 29)</code> 的设备</li><li>具有 <code>(LV &lt; 28, RV &gt;= 29)</code> 的设备，不包括已在使用方法 B 的设备</li><li>谷歌：Pixel 3 和 3a 为 <code>(RV &gt;= 29)</code> 时</li></ul></li></ul><h3 id="讨论" tabindex="-1">讨论 <a class="header-anchor" href="#讨论" aria-hidden="true">#</a></h3><p>从文档来看，谷歌对 SAR 的定义只考虑了内核如何引导设备（上表中的<strong>初始根目录</strong>），这意味着从谷歌的角度来看，只有使用<strong>方法B</strong>的设备才被正式视为 SAR 设备。</p><p>然而，对于 Magisk 来说，真正的区别在于设备在完全启动时使用的是什么（上表中的<strong>最终根目录</strong>），这意味着<strong>就 Magisk 而言，方法 B 和方法 C 都是 SAR 的一种形式</strong>，但实施方式不同。除非另有特别说明，否则本文件后面提到的每一个 SAR 实例都将参考 <strong>Magisk 的定义</strong>。</p><p>通俗地说，方法 C 的标准有点复杂：您的设备足够现代，可以使用 Android 10+ 启动，或者您在使用方法 A 的设备上运行 Android 10+ 第三方 ROM。</p><ul><li>任何运行 Android 10+ 的设备都将自动使用方法 C</li><li><strong>方法 B 设备卡在方法 B 上</strong>，唯一的例外是 Pixel 3 和 3a，Google 对设备进行了改造以适应新方法。</li></ul><p>SAR 是 <a href="https://source.android.google.cn/devices/architecture#hidl" target="_blank" rel="noreferrer">Project Treble</a> 中非常重要的一部分，因为 rootdir 应该与平台绑定。这也是方法 B 和 C 带有 <code>(LV &gt;= ver)</code> 标准的原因，因为谷歌每年都强制所有 OEM 遵守更新的要求。</p><h2 id="一些历史" tabindex="-1">一些历史 <a class="header-anchor" href="#一些历史" aria-hidden="true">#</a></h2><p>当谷歌发布第一代 Pixel 时，它还推出了 <a href="https://source.android.google.cn/devices/tech/ota/ab" target="_blank" rel="noreferrer">A/B（无缝）系统更新</a>。由于<a href="https://source.android.google.cn/devices/tech/ota/ab/ab_faqs" target="_blank" rel="noreferrer">存储大小问题</a>，与仅 A 相比有几个区别，最相关的是删除 <code>recovery</code> 分区和 recovery ramdisk ，合并到<code>boot</code>中。</p><p>让我们回到 Google 第一次设计 A/B 的时候。如果使用 SAR（当时只有引导方法 B 存在），内核不需要 <code>initramfs</code> 来引导 Android（因为 rootdir 在 <code>system</code> 中）。这意味着我们可以很聪明，只需将 recovery ramdisk（包含极简的 Linux 环境）塞入 <code>boot</code> ，删除 <code>recovery</code> ，然后让内核根据引导加载程序的信息选择要使用的任何根目录（ramdisk 或 <code>system</code>）。</p><p>随着时间从 Android 7.1 到 Android 10 的流逝，谷歌推出了<a href="https://source.android.google.cn/devices/tech/ota/dynamic_partitions/implement" target="_blank" rel="noreferrer">动态分区</a>。这对 SAR 来说是个坏消息，因为 Linux 内核无法直接理解这种新的分区格式，因此无法直接将 <code>system</code> 挂载为 rootdir。这是他们想出引导方法 C 的时候：总是引导到 <code>initramfs</code> ，并让 userspace 处理其余的引导。这包括决定是否启动到 Android 或 recovery，或者他们正式称之为 <code>USES_RECOVERY_AS_BOOT</code> 。</p><p>一些使用带有 2SI 的 A/B 的现代设备还带有 <code>recovery_a/_b</code> 分区。谷歌的标准正式支持这一点。当 recovery 存储在单独的分区中时，这些设备将只使用 boot ramdisk 引导到 Android。</p><h2 id="将事物拼凑在一起" tabindex="-1">将事物拼凑在一起 <a class="header-anchor" href="#将事物拼凑在一起" aria-hidden="true">#</a></h2><p>有了上面的所有知识，现在我们可以将所有 Android 设备分类为以下不同类型：</p><table><thead><tr><th style="text-align:center;">类型</th><th style="text-align:center;">引导方式</th><th style="text-align:center;">分区</th><th style="text-align:center;">2SI</th><th style="text-align:center;">在 <code>boot</code> 里的 ramdisk</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>I</strong></td><td style="text-align:center;">A</td><td style="text-align:center;">A-only</td><td style="text-align:center;">No</td><td style="text-align:center;"><code>boot</code> ramdisk</td></tr><tr><td style="text-align:center;"><strong>II</strong></td><td style="text-align:center;">B</td><td style="text-align:center;">A/B</td><td style="text-align:center;">Any</td><td style="text-align:center;"><code>recovery</code> ramdisk</td></tr><tr><td style="text-align:center;"><strong>III</strong></td><td style="text-align:center;">B</td><td style="text-align:center;">A-only</td><td style="text-align:center;">Any</td><td style="text-align:center;"><em><strong>N/A</strong></em></td></tr><tr><td style="text-align:center;"><strong>IV</strong></td><td style="text-align:center;">C</td><td style="text-align:center;">Any</td><td style="text-align:center;">Yes</td><td style="text-align:center;">混合 ramdisk</td></tr></tbody></table><p>这些类型按首次可用时的时间顺序排序。</p><ul><li><strong>I 类</strong>：好的旧传统 ramdisk 引导</li><li><strong>II 类</strong>：旧版 A/B 设备。Pixel 1 是这种类型的第一个设备，同时也是第一个 A/B 和 SAR 设备。</li><li><strong>III 类</strong>：2018年末-2019年仅限A级的设备<strong>就 Magisk 而言，这是迄今为止最糟糕的一种设备类型</strong></li><li><strong>IV 类</strong>：所有使用引导方法 C 的设备都是 IV 型设备。A/B IV 类 ramdisk 可以根据引导加载程序的信息启动到 Android 或 recovery；A-only IV 类 ramdisk 只能引导到 Android。</li></ul><p>关于 III 类设备的更多详细信息：Magisk 始终安装在引导映像的 ramdisk 中。对于所有其他类型的设备，由于其 <code>boot</code> 分区包含 ramdisk，因此可以通过 Magisk app 或第三方 recovery 中的刷入 ZIP 修补引导映像来轻松安装 Magisk。然而，对于 III 型设备，它们<strong>仅限于将 Magisk 安装到 <code>recovery</code> 分区</strong>中。Magisk 在正常启动时无法运行；相反，III 类设备用户必须始终重新启动到 recovery，以保持 Magisk 访问。</p><p>一些 III 类设备的引导加载程序仍然会接受并提供手动添加到内核“引导”映像中的 <code>initramfs</code>（例如一些小米手机），但许多设备不接受（例如三星 S10，Note 10）。这完全取决于 OEM 如何实现其引导加载程序。</p><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-hidden="true">#</a></h2><ul><li><a href="https://topjohnwu.github.io/Magisk/boot.html" target="_blank" rel="noreferrer">Magisk Android Booting Shenanigans</a>（官方）</li></ul>',30),i=[n];function s(l,a,c,g,h,A){return o(),t("div",null,i)}const u=e(d,[["render",s]]);export{p as __pageData,u as default};
